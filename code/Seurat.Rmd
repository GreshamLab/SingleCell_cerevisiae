---
title: "Seurat"
author: "Simone Zaghen"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    toc: true
    number_section: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../results/") })

---

# Load packages

```{r, results='hide', message=FALSE}
#Load packages from CRAN
library("tidyverse")
library("reshape2")
library("Seurat")
library("conflicted")

#Solve conflicts
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")

```

# Load dataset and filter data 

Here I'm loading the dataset from [this paper](https://doi.org/10.1101/2023.09.21.558277).

The dataset can be downloaded from [supplementary data 1](https://zenodo.org/records/8371195).

The dataset "is single-cell response to rapamycin count data deposited in GEO with accession GSE242556. It is a 173348 rows Ã— 5847 columns TSV.GZ file where the first row is a header, the first 5843 columns are integer gene counts, and the final 4 columns ('Gene', 'Replicate', 'Pool', and 'Experiment') are cell-specific metadata."

```{r, results='hide', message=FALSE}
rawdata <- read_tsv("../data/2021_RAPA_TIMECOURSE.tsv.gz") #load raw data
metadata <- read_tsv("../data/Cell_Cycle_Metadata.tsv.gz") #cell cycle data

```

Do some data wrangling

```{r}
df <- cbind(rawdata, metadata) #merge data and metadata

df <- df %>%
  filter(Pool %in% c("1", "2")) %>% #timepoints before rapamycin treatment
  filter(Gene %in% "WT") %>% #only wt strain
  drop_na()
  
counts <- select(df, 1:5843) #exclude the metadata
counts <- as.data.frame(t(counts)) #Seurat: rows as genes, columns as cell
colnames(counts) <- str_remove(colnames(counts), "V") #fix colnames

meta <- select(df, 5844:5849) #retain metadata 

```

Create the Seurat object and add the metadata to it

```{r}
#Only load things after filtering so it's faster
srat <- CreateSeuratObject(counts, project = "cerevisiae") 
srat <- AddMetaData(srat, meta)

rm(list = c("counts", "meta", "metadata"))

```

```{r}
VlnPlot(srat, 
        features = c("nFeature_RNA","nCount_RNA"),
        ncol = 2, 
        pt.size = 0,
        group.by = "Cell_Cycle_Phase") & 
  theme(plot.title = element_text(size=10))


#nFeature_RNA: number of expressed (detected) genes per same cell
#nCount_RNA: number of UMI reads detected per cell

```

```{r}
FeatureScatter(srat, 
               feature1 = "nCount_RNA", 
               feature2 = "nFeature_RNA",
               group.by = "Cell_Cycle_Phase")

```

```{r}
srat <- NormalizeData(srat, 
                      normalization.method = "RC",
                      scale.factor = 10000)

```


```{r}
srat <- FindVariableFeatures(srat, selection.method = "vst")

top10 <- head(VariableFeatures(srat), 10)
top10
```


```{r}
plot1 <- VariableFeaturePlot(srat)
LabelPoints(plot = plot1, points = top10, repel = TRUE, xnudge = 0, ynudge = 0)

```


```{r}
all.genes <- rownames(srat)
srat <- ScaleData(srat, features = all.genes)

```

```{r}
srat <- RunPCA(srat, features = VariableFeatures(object = srat))
print(srat[["pca"]], dims = 1:15, nfeatures = 5)
VizDimLoadings(srat, dims = 1:15, reduction = "pca")
DimPlot(srat, reduction = "pca") + NoLegend()
DimHeatmap(srat, dims = 1, cells = 500, balanced = TRUE)
DimHeatmap(srat, dims = 1:15, cells = 500, balanced = TRUE)

```

```{r}
ElbowPlot(srat)

```

Here i will use 15 dims since from the elbow plot we can see that after the 15th dimensions not much is explained by the PCs. 

```{r}
srat <- FindNeighbors(srat, dims = 1:15)
srat <- FindClusters(srat, resolution = 0.5)
head(Idents(srat), 5)

```

```{r}
srat <- RunUMAP(srat, dims = 1:15)
DimPlot(srat, reduction = "umap")

```

```{r}
DimPlot(srat, reduction = "umap", group.by = "Cell_Cycle_Phase")

```

create discreate intervals for time so i can use those to cluster

```{r}
srat@meta.data <- srat@meta.data %>%
  mutate(max   = max(Cell_Cycle_Time), 
         min   = min(Cell_Cycle_Time), 
         width = (max-min)/30, 
         bin1  = ceiling((Cell_Cycle_Time-min)/width),
         bin   = ifelse(Cell_Cycle_Time==min, bin1 + 1, bin1)
         ) 


```

```{r}
DimPlot(srat, reduction = "umap", group.by = "bin") +
  scale_fill_gradient(low = "#132B43", high = "#56B1F7")


```

This is fine and divided by time intervals, the issue is the scale that is not easy to understand! 



