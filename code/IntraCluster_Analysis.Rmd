---
title: "Intra-cluster variance analysis"
author: "Simone Zaghen"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    toc: true
    number_section: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../results/") })

---

# Load packages

```{r, results='hide', message=FALSE}
#Load packages from CRAN
library("tidyverse")
library("reshape2")
library("ggpubr")
library("biomaRt")

library("conflicted")

#Solve conflicts
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")

```

# Load dataset and filter data 

```{r, results='hide', message=FALSE}
rawdata <- read_tsv("../data/2021_RAPA_TIMECOURSE.tsv.gz") #load raw data
metadata <- read_tsv("../data/Cell_Cycle_Metadata.tsv.gz") #cell cycle data

#load gene info
ensembl <- useMart(biomart = "ENSEMBL_MART_ENSEMBL",
                   dataset = "scerevisiae_gene_ensembl",
                   host = "https://Jul2018.archive.ensembl.org") 

gen_des <- getBM(attributes = c("ensembl_gene_id",
                                "description",
                                "external_gene_name"),
                 mart = ensembl)

colnames(gen_des) <- c("genes", 
                       "description",
                       "common_name")

rm("ensembl")

```

Do some data wrangling and divide cells into 3 minutes bins.

```{r}
df <- cbind(rawdata, metadata) %>% #merge data and metadata
  filter(Pool %in% c("1", "2")) %>% #timepoints before rapamycin treatment
  filter(Gene %in% "WT") %>% #only wt strain
  drop_na() %>% #remove empty levels
  mutate(max = max(Cell_Cycle_Time),
         min = min(Cell_Cycle_Time),
         width = (max-min)/30,
         bin1 = ceiling((Cell_Cycle_Time - min)/width),
         time_interval = ifelse(Cell_Cycle_Time == min, 
                                bin1 + 1, 
                                bin1)) %>%
  mutate(time_interval = time_interval * 3) %>% #each bin should reflect minutes
  select(-c("max", "min", "width", "bin1")) %>%
  mutate(time_interval = factor(time_interval))

```

Check how many cells/bin we have

```{r}
df %>%
  count(time_interval) %>% 
  ggplot(aes(x = time_interval,
                   y = n)) +
  geom_bar(stat = "identity") +
  ylab("#cells")

```

# Perform intra-cluster analysis

For each bin, normalize and remove high and low counts. Then calculate mean, sd, and coefficient of variation and build a linear model (coefficient of variation vs mean). Then calculate the residuals, and adjust them based on the mean. 

```{r}
#define lists to store output
model_list <- list()
stats_list <- list()
plot_list <- list()

for (i in 1:length(levels(df$time_interval))) {

  #Create dataframe for specific timepoint
  tmp <- df %>%
    filter(time_interval %in% levels(df$time_interval)[i]) %>%
    select(-c("Gene", "Replicate", "Pool", "Experiment", "Cell_Cycle_Phase",
              "Cell_Cycle_Time", "time_interval")) %>%
    filter(rowSums(.) < 15000) #remove cells with counts above 15000

  tmp <- tmp*10000/rowSums(tmp) #normalize df
  
  #calculate mean, sd, and coefficient of variation
  tmp_stats <- as.data.frame(t( #transpose to make df ggplot friendly
    rbind(mean = apply(tmp, 2, mean, na.rm = T),
          sd = apply(tmp, 2, sd, na.rm = T),
          CV = (apply(tmp, 2, sd))/(apply(tmp, 2, mean, na.rm = T))))) %>%
    filter(mean > 0.01) %>% #remove low expr
    drop_na() #drop empty levels

  #fit the model
  tmp_model <- lm(log10(CV) ~ log10(mean), 
                  data = tmp_stats, 
                  row.names(tmp_stats$genes))

  #calculate residuals for each gene and adjust them
  tmp_residuals <- data.frame(row.names = names(tmp_model$residuals), 
                              residuals = tmp_model$residuals)
                
  tmp_stats <- merge(tmp_stats, 
                     tmp_residuals, 
                     by = "row.names") %>%
    rename("genes" = "Row.names") %>%
    mutate(adj_res = residuals/mean) %>% #adjust residuals
    merge(gen_des, by = "genes") %>%
    distinct() %>% #only keep unique rows
    arrange(desc(adj_res)) %>%
    relocate(common_name, .after = genes)

  #create model plot
  tmp_plot <-
    tmp_stats %>%
    ggplot(aes(x = log10(mean),
             y = log10(CV))) +
    geom_point() +
    geom_abline(slope = coef(tmp_model)[["log10(mean)"]], 
                intercept = coef(tmp_model)[["(Intercept)"]],
                color = "red",
                linewidth = 1) +
    ggtitle(paste0(
      levels(df$time_interval)[i],
      " minutes",
      "_log of x and y, mean > 0.01"))

  #Save oututs
  model_list[[levels(df$time_interval)[i]]] <- tmp_model #save model
  stats_list[[levels(df$time_interval)[i]]] <- data.frame(tmp_stats) #save stats
  plot_list[[levels(df$time_interval)[i]]] <- tmp_plot #save stats
}

rm(list=ls(pattern="^tmp"))

```

# Plot linear regressions

```{r, fig.height=40, fig.width=12}
ggarrange(plotlist = plot_list, ncol=3, nrow =10)

```

# Run GSA

```{r, warning=FALSE, eval=FALSE}
GSEA_list <- list()

for (i in 1:length(stats_list)) {
    original_gene_list <- stats_list[[i]]$adj_res #rank on residuals
    names(original_gene_list) <- stats_list[[i]]$genes # name the vector
    
    # sort the list in decreasing order (required for clusterProfiler)
    gene_list <- na.omit(original_gene_list) # omit any NA values 
    gene_list = sort(gene_list, decreasing = TRUE)
    
    #Run GSEA
    tmp_GSEA <- 
      gseGO(geneList = gene_list, 
            ont ="ALL", 
            keyType = "ENSEMBL", 
            nPerm = 10000, 
            minGSSize = 5, 
            maxGSSize = 500, 
            pvalueCutoff = 0.05,
            verbose = FALSE, 
            OrgDb = org.Sc.sgd.db, 
            pAdjustMethod = "none")
    
    #Store results in a list
    GSEA_list[[levels(df$time_interval)[i]]] <- tmp_GSEA #save model

}

#Plot GSEA results

#fig.width=8, fig.height=12
for (i in 1:length(GSEA_list)){
  
  print(dotplot(GSEA_list[[i]], 
          showCategory=10, 
          split=".sign",
          title = paste0(
            "Timepoint ",
            levels(df$time_interval)[i],
            " minutes, adjusted residuals")) +
    facet_grid(.~.sign))
}

```

