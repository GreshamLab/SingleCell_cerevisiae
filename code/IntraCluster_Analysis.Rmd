---
title: "04_Intra-cluster variance analysis"
author: "Simone Zaghen"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    toc: true
    number_section: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../results/") })

---

# Load packages

```{r, results='hide', message=FALSE}
#Load packages from CRAN
library(tidyverse)
library(reshape2)
library(ggpubr)
library(biomaRt)
library(readxl)
library(conflicted)
library(clusterProfiler)
library(pathview)
library(enrichplot)
library(org.Sc.sgd.db)


#Solve conflicts
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("rename", "dplyr")
conflict_prefer("intersect", "base")

```

# Load dataset and filter data 

```{r, results='hide', message=FALSE}
rawdata <- read_tsv("../data/2021_RAPA_TIMECOURSE.tsv.gz") #load raw data
metadata <- read_tsv("../data/Cell_Cycle_Metadata_01112024.tsv.gz") #cell cycle data

#load gene info
ensembl <- useMart(biomart = "ENSEMBL_MART_ENSEMBL",
                   dataset = "scerevisiae_gene_ensembl",
                   host = "https://Jul2018.archive.ensembl.org") 

gen_des <- getBM(attributes = c("ensembl_gene_id",
                                "description",
                                "external_gene_name"),
                 mart = ensembl)

colnames(gen_des) <- c("genes", 
                       "description",
                       "common_name")

rm("ensembl")

```

Do some data wrangling and divide cells into 3 minutes bins.

```{r}
df <- cbind(rawdata, metadata) %>% #merge data and metadata
  filter(Pool %in% c("1", "2")) %>% #timepoints before rapamycin treatment
  filter(Gene %in% "WT") %>% #only wt strain
  drop_na() %>% #remove empty levels
  mutate(max = max(Cell_Cycle_Time),
         min = min(Cell_Cycle_Time),
         width = (max-min)/30,
         bin1 = ceiling((Cell_Cycle_Time - min)/width),
         time_interval = ifelse(Cell_Cycle_Time == min, 
                                bin1 + 1, 
                                bin1)) %>%
  mutate(time_interval = time_interval * 3) %>% #each bin should reflect minutes
  select(-c("max", "min", "width", "bin1")) %>%
  mutate(time_interval = factor(time_interval))

```

Check how many cells we have in each bin

```{r}
df %>%
  count(time_interval) %>% 
  ggplot(aes(x = time_interval,
                   y = n)) +
  geom_bar(stat = "identity") +
  ylab("#cells")

```

# Intra-cluster analysis and plot regression lines

For each bin, normalize and remove high and low counts. Then calculate mean, sd, and coefficient of variation and build a linear model (coefficient of variation vs mean). Then calculate the residuals, and adjust them based on the mean. In the past we used adjusted residuals, but we decided not to use them here for further plots because when the mean is very low, the adj_res become very high and they 'overpower' more interesting genes with higher residuals. We still calculate them here in case a quick comparison is necessary. 

```{r}
#define lists to store output
model_list <- list()
stats_list <- list()
plot_list <- list()

for (i in 1:length(levels(df$time_interval))) {

  #Create dataframe for specific timepoint
  tmp <- df %>%
    filter(time_interval %in% levels(df$time_interval)[i]) %>%
    select(-c("Gene", "Replicate", "Pool", "Experiment", "Cell_Cycle_Phase",
              "Cell_Cycle_Time", "time_interval")) %>%
    filter(rowSums(.) < 15000) #remove cells with counts above 15000

  tmp <- tmp*10000/rowSums(tmp) #normalize df
  
  #calculate mean, sd, and coefficient of variation
  tmp_stats <- as.data.frame(t( #transpose to make df ggplot friendly
    rbind(mean = apply(tmp, 2, mean, na.rm = T),
          sd = apply(tmp, 2, sd, na.rm = T),
          CV = (apply(tmp, 2, sd))/(apply(tmp, 2, mean, na.rm = T))))) %>%
    filter(mean > 0.01) %>% #remove low expr
    drop_na() #drop empty levels

  #fit the model
  tmp_model <- lm(log10(CV) ~ log10(mean), 
                  data = tmp_stats, 
                  row.names(tmp_stats$genes))

  #calculate residuals for each gene and adjust them
  tmp_residuals <- data.frame(row.names = names(tmp_model$residuals), 
                              residuals = tmp_model$residuals)
                
  tmp_stats <- merge(tmp_stats, 
                     tmp_residuals, 
                     by = "row.names") %>%
    rename("genes" = "Row.names") %>%
    mutate(adj_res = residuals/mean) %>% #adjust residuals
    merge(gen_des, by = "genes") %>%
    distinct() %>% #only keep unique rows
    arrange(desc(adj_res)) %>%
    relocate(common_name, .after = genes)

  #create model plot
  tmp_plot <-
    tmp_stats %>%
    ggplot(aes(x = log10(mean),
             y = log10(CV))) +
    geom_point() +
    geom_abline(slope = coef(tmp_model)[["log10(mean)"]], 
                intercept = coef(tmp_model)[["(Intercept)"]],
                color = "red",
                linewidth = 1) +
    ggtitle(paste0(
      levels(df$time_interval)[i],
      " minutes",
      "_log of x and y, mean > 0.01"))

  #Save oututs
  model_list[[levels(df$time_interval)[i]]] <- tmp_model #save model
  stats_list[[levels(df$time_interval)[i]]] <- data.frame(tmp_stats) #save stats
  plot_list[[levels(df$time_interval)[i]]] <- tmp_plot #save stats
}

rm(list=ls(pattern="^tmp"), gen_des)

```

```{r, fig.height=24, fig.width=12}
ggarrange(plotlist = plot_list, ncol=3, nrow =10)

```

# Plot cell cycle genes

As a sanity check, plot the both the non-adjusted and the adjusted residuals of cell cycle genes. Their residuals should be very low since cells are clustered based on time. In the past we used adjusted residuals, but we decided not to use them here for further plots because when the mean is very low, the adj_res become very high and they 'overpower' more interesting genes with higher residuals. We still calculate them here to quickly compare them with the non-adjusted residuals. 

```{r, fig.height=40, fig.width=7}
#import cell cycle annotated genes provided by Chris
cell_cycle_genes <- read_excel("../data/Yeast_Transcriptional_Regulation.xlsx", 
                               sheet = 1) %>%
  rename("Systematic_Name" = "Systematic Name") %>%
  filter(Pathway %in% "Cell Cycle") %>%
  select(c("Pathway", "Systematic_Name", "Gene")) %>%
  filter(Systematic_Name != "#N/A")
cell_cycle_genes <- cell_cycle_genes$Systematic_Name

#plot cell cycle genes
stats_list %>%
  map(~ filter(.x, #only keep genes in the cell_cycle_genes vector
               genes %in% unique(grep(paste(cell_cycle_genes,
                                            collapse="|"),
                                            genes,
                                            value = T)))) %>%
  map2(names(stats_list), ~.x %>% 
         mutate(Time_Point = .y)) %>% #add time column
  bind_rows() %>%
  mutate(Time_Point = as.numeric(Time_Point)) %>%
  select(c("genes", "common_name", "mean", "residuals", "adj_res", "Time_Point")) %>%
  melt(id = c("genes", "common_name", "Time_Point")) %>%
  ggplot(aes(x = Time_Point, #plot
             y = value)) +
  geom_point() +
  scale_x_continuous(breaks = seq(from = 0,
                                  to = 90,
                                  by = 6)) +
  expand_limits(x = 0, y = 0) +
  facet_wrap(common_name ~ variable, 
             scales = "free",
             ncol = 3)
rm("cell_cycle_genes")

```

```{r, warning=FALSE}
stats_list %>%
  map2(names(stats_list), ~.x %>% 
         mutate(Time_Point = .y)) %>% #add time column
  bind_rows() %>% 
  select(c("genes", "mean", "residuals", "adj_res")) %>%
  melt(id = "genes") %>%
  ggplot(aes(x = value)) +
  geom_density(stat = "density",
               position = "identity") +
    xlim(-2,2) +
    facet_wrap(~variable, 
               scales = "free")
    
```

# Rank combine

To the genes with the highest coefficient of variation in the whole dataset, first only keep genes common in all time points, and then rank the genes in each time bin. The lowest rank for the lowest values. Then group by genes and sum the ranks for each gene - then extract the genes that rank the highest. These are the genes with the highest variability.

```{r, warning=FALSE, message=FALSE}
#find genes common in all timepoints
common_genes <- Reduce(intersect, 
                       lapply(stats_list, 
                              function(x) {x$genes}))
#calculate rank
rank_combine <- 
  stats_list %>%
  map(~.x %>%
        filter(genes %in% common_genes) %>% #only keep genes in all timepoints
        drop_na() %>%
        mutate(rank = rank(residuals)) %>% #rank based on non-adjusted residuals
        select(c("genes", "common_name", "rank", "description"))) %>%
  map2(names(stats_list), ~.x %>% 
         mutate(Time_Point = .y) %>% #add time column
         mutate(Time_Point = as.numeric(Time_Point))) %>% #convert time to num
  bind_rows() %>%
  group_by(genes, common_name, description) %>% 
  summarise(rank_combined = sum(rank)) %>%
  arrange(desc(rank_combined)) #arrange from highest to lowest

rm(common_genes)
write.csv2(rank_combine, "../results/04_RankCombine.csv", row.names = F)

```

Plot genes with the highest ranks

```{r, fig.height=60, fig.width=7}
genes_to_plot <- as.character(rank_combine$genes)[2:20]

stats_list %>%
  map(~ filter(.x, 
               genes %in% unique(grep(paste(genes_to_plot,
                                            collapse="|"),
                                            genes,
                                            value = T)))) %>%
  map2(names(stats_list), ~.x %>% 
         mutate(Time_Point = .y) %>%
         mutate(Time_Point = as.numeric(Time_Point))) %>% #add time column
  bind_rows() %>%
  select(c("genes", "common_name", "mean", "residuals", "Time_Point")) %>%
  melt(id = c("genes", "common_name", "Time_Point")) %>%
  ggplot(aes(x = Time_Point, #plot
             y = value)) +
  geom_point() +
    scale_x_continuous(breaks = seq(from = 0,
                                  to = 90,
                                  by = 6)) +
  expand_limits(x = 0, y = 0) +
  facet_wrap(common_name ~ variable, 
             scales = "free", 
             ncol = 2)

```

#GSEA on rank combined list

```{r, eval=FALSE}
original_gene_list <- rank_combine$rank_combined #rank on residuals
names(original_gene_list) <- rank_combine$genes # name the vector
# sort the list in decreasing order (required for clusterProfiler)
gene_list<-na.omit(original_gene_list) # omit any NA values 
gene_list = sort(gene_list, decreasing = TRUE)

# Run GSEA
gsea <- 
  gseGO(geneList = gene_list, 
        ont ="all", 
        OrgDb = org.Sc.sgd.db, 
        keyType = "ENSEMBL", 
        nPerm = 10000, 
        minGSSize = 4, 
        maxGSSize = 200, 
        pvalueCutoff = 0.05, 
        pAdjustMethod = "none",
        scoreType = "pos",
        verbose = FALSE)

dotplot(gsea, 
        showCategory=10, 
        split=".sign", 
        title = "Rank combined residuals") + 
  facet_grid(.~.sign) 

```


